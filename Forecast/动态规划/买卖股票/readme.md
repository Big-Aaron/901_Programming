# **股票问题**

| 股票问题 | 特点 | 
| :---: | :---: |
| 121.买卖股票的最佳时机 I | 只能买卖一次 |
| 122.买卖股票的最佳时机 II | 可以买卖多次 |
| 123.买卖股票的最佳时机 III | 最多买卖两次 |
| 188.买卖股票的最佳时机 IV | 最多买卖K次 |
| 309.最佳买卖股票时机含冷冻期 | 买卖多次，卖出后有一天冷冻期 |
| 714.买卖股票的最佳时机含手续费 | 买卖多次，每次有手续费 |

# 1、买卖股票的最佳时机 I

    给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。

    你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。

    返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。

举个例子：

    输入：[7,1,5,3,6,4]
    输出：5
    解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
    注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。

## 暴力破解法
    
## 贪心算法

## 动态规划

动规五步曲

### 1、确定dp数组的含义

每一天都结束时两个状态，持有 和 不持有。

* **持有** 分为两种情况:

    1：今天购买股票；
    2：之前购买过股票且没有卖出。

* **不持有** 分为两种情况：

    1：之前卖过股票（只允许买卖一次）；
    2：今天卖出股票；
    
 
dp[i][0] 表示第 i 天持有股票所得最大利润

dp[i][1] 表示第 i 天不持有股票所得最大利润

### 2、确定递推公式

* dp[i][0] 有两种来源：

    第 i 天购买股票: dp[i][0] = -prices[i];（**_只能买一次_**）
    
    第 i 天之前购买过股票且没有卖出: dp[i][0] = dp[i-1][0];

所以 dp[i][0] = max(-price[i], dp[i-1][0]);

* dp[i][1] 有两种来源：

    第 i 天未购买股票: dp[i][1] = dp[i-1][1];
    
    第 i 天卖出: dp[i][1] = dp[i-1][0] + prices[i];

所以 dp[i][0] = max(dp[i-1][0] + prices[i], dp[i-1][1]);

### 3、dp数组如何初始化

可以看出 dp[i] 需要 dp[i-1] 的数据，所以 dp[0] 的数据要初始化；

dp[0][0] 表示第 0 天持有股票 dp[0][0] = -prices[0];

dp[0][1] 表示第 1 天不持有股票 dp[0][1] = 0;

### 4、确定遍历顺序

dp[i] 由 dp[i-1] 推导出，所以从前向后遍历。

### 5、举例推导dp数组

输入：[7,1,5,3,6,4]为例

| i |dp[i][0] | dp[i][1] | 
| :---: | :---:| :---: |
| 0 | -7 | 0 | 
| 1 | -1 | 0 | 
| 2 | -1 | 4 | 
| 3 | -1 | 4 | 
| 4 | -1 | 5 | 
| 5 | -1 | **_5_** | 

### 6、C语言代码

[121.买卖股票的最佳时机 I](./121.c)




